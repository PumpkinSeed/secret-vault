# Secret Vault

A PoC showing how even a more complex use-case can be implemented relatively easily - this contract generates and stores private keys, exposing an interface for a user to sign data (e.g. ethereum transactions) while keeping the private key safe. Inspired in part by the suggestion by [Gridlock Network](https://github.com/GridlockNetwork/Whitepaper).

What is there to see here?

* A basic, non-auditing, probably insecure PRNG mechanism for generating keys. We use randomness generated by the client to ensure that an observer cannot predict keys generated by the contract.

* An access-control system to manage access to private keys - Creating a "server-side" API key, and storing a user-generated password. In order to sign data you must provide both the password and the API key. 

* Usage of libsecp256k1 to create valid secp256k1 signatures on-chain

What isn't there to see here?

* Properly auditing cryptographic anything (no constant time functions, no cryptanalysis, etc.)

* No deletion of keys or changing of passwords (though this would be pretty easy)

* Using the private keys for anything other than signing with secp256k1 (encryption, ed25519, nist etc.)
